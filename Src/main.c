/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "system_stm32f4xx.h"
#include "stm32f401re_gpio.h"
#include "stm32f401re_rcc.h"
#include "stm32f401re_usart.h"
#include "misc.h"
#include "eventman.h"
#include "timer.h"
#include "led.h"
#include "melody.h"
#include "lightsensor.h"
#include "temhumsensor.h"
#include "eventbutton.h"
#include "button.h"
#include "Ucglib.h"
#include "uartcmd.h"
#include "serial.h"
#include "stdio.h"
#include "string.h"
#include "buff.h"

/*Define GPIO_PIN----------------------------------------*/
#define USART2_RX							GPIO_Pin_3
#define USART2_TX							GPIO_Pin_2
#define USART2_GPIO							GPIOA
#define USART2_GPIO_CLOCK					RCC_AHB1Periph_GPIOA
#define USART2_CLOCK						RCC_APB1Periph_USART2

#define USARTx_Baud							9600

#define SIZE_QUEUE_DATA_RX					256			//bộ nhớ tối đa của con trỏ.
#define RX_BUFFER_SIZE1						16			//kích thước tối đa của mảng.

#define FRAME_SOF 							0xB1
#define FRAME_ACK							0x06
#define FRAME_NACK							0x15
#define CXOR_INIT_VAL						0xFF

#define	CMD_ID								RxBuffer[2]
#define	CMD_TYPE							RxBuffer[3]
#define	CMD_DATA_1							RxBuffer[4] //Led: left/right board, button: B1/2/3/4/5
#define	CMD_DATA_2							RxBuffer[5] //Led: color
#define	CMD_DATA_LED_ONOFF					RxBuffer[8] // 5 state led : 0-red 1-green 2-blue 3-white 4-black

#define	FRAME_ID							frame[3]
#define	FRAME_TYPE							frame[4]
#define	FRAME_DATA1							frame[5]
#define	FRAME_DATA2							frame[6]
#define	FRAME_SEQUECE						frame[7]

#define RX_BUFFER_SIZE                      30

#define	ID_TEMP								0x84
#define	ID_HUMI								0x85
#define	ID_LIGHT							0x86

/*Variables----------------------------------------------*/
static uint8_t	byRxBufState;							//
static uint8_t	byIndexRxBuf;							//thứ tự của buf
static uint8_t	byCheckXorRxBuf;						//check xor dữ liệu

buffqueue_t QueueRx ;									//struct queue dùng để nhận dữ liệu(Con trỏ để trỏ tới bộ đệm.)
static uint8_t	pBuffDataRx[SIZE_QUEUE_DATA_RX];		//mảng lưu dữ liệu của struct queue

uint8_t RxBuffer[RX_BUFFER_SIZE1]={0};					//

uint8_t	DataReceive = 0;

ucg_t ucg;
uint8_t frame[9]={0xB1, 0x07, 0x00, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00};
uint8_t frameLED[12]={0xB1, 0xa, 0x00, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
uint8_t frameBuzzer[8]={0xB1, 0x06, 0x00, 0x04, 0x02, 0x00, 0x00, 0x00};

uint8_t Sequece=1;

static uint8_t temperture,humidity;
static uint16_t light;
static char str1[20]="";
static char str2[20]="";
static char str3[20]="";

uint8_t check=0;

static SSwTimer TempHumScan= NO_TIMER;
static SSwTimer LightScan= NO_TIMER;

uint8_t TempHumCheck=0;

/*Function-----------------------------------------------*/
void USART2_Init();
void Serial_Init1();
uint8_t PollRxBuff();
static void check_data_transmis();
void sendData_toHost(uint8_t ID,uint16_t data);
void Task_multiSensorScan();
void processSerialReceiver1();
void LED_PacketRespond(uint8_t id,uint8_t color,uint8_t state);
void Buzzer_PacketRespond(uint8_t state);
void AppInitCommon();

/**
 * @func	USART2_Init
 *
 * @brief	Initialization USART2
 *
 * @param	none
 *
 * @retval	none
 */
void USART2_Init()
{
	GPIO_InitTypeDef GPIO_InitStructure;
	USART_InitTypeDef USART_InitStructure;
	NVIC_InitTypeDef 	NVIC_InitStructure;

	//Enable Clock USART2 and GPIOC
	RCC_AHB1PeriphClockCmd(USART2_GPIO_CLOCK,ENABLE);

	//Initializes GPIO Use USART2 Peripheral
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz ;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP ;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP ;

	GPIO_InitStructure.GPIO_Pin = USART2_RX | USART2_TX;

	GPIO_Init(USART2_GPIO, &GPIO_InitStructure);

	//Initializes GPIO as Alternate function mode
	GPIO_PinAFConfig(USART2_GPIO, GPIO_PinSource3, GPIO_AF_USART2);
	GPIO_PinAFConfig(USART2_GPIO, GPIO_PinSource2, GPIO_AF_USART2);

	//Initializes USART1 Peripheral
	RCC_APB1PeriphClockCmd(USART2_CLOCK, ENABLE);

	USART_InitStructure.USART_BaudRate = USARTx_Baud;
	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
	USART_InitStructure.USART_StopBits = USART_StopBits_1 ;
	USART_InitStructure.USART_Parity = USART_Parity_No ;
	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None ;
	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;

	USART_Init(USART2, &USART_InitStructure);


	//Enable USART
	USART_Cmd(USART2, ENABLE);

	//Enable USARTx Receive interrupts
	USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);

	//NVIC configuration
	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);

	//Enable the USARTx Interrupt
	NVIC_InitStructure.NVIC_IRQChannel = USART2_IRQn ;
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0 ;
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0 ;
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE ;

	NVIC_Init(&NVIC_InitStructure);
}

/**
 * @func	USART2_Custom_IRQHandler
 *
 * @brief	Interrupt USART2
 *
 * @param	none
 *
 * @retval	none
 */
void USART2_Custom_IRQHandler(void)
{
	if(USART_GetITStatus(USART2, USART_IT_RXNE)== SET)
	{
		DataReceive = USART_ReceiveData(USART2);
		bufEnDat(&QueueRx,&DataReceive);
	}
	USART_ClearITPendingBit(USART2, USART_IT_RXNE);
}

/**
 * @func	Serial_Init1
 *
 * @brief	Initialization buffer & call Initialization USART2 function
 *
 * @param	none
 *
 * @retval	none
 */
void Serial_Init1()
{
	bufInit(pBuffDataRx,&QueueRx,sizeof(pBuffDataRx[0]),SIZE_QUEUE_DATA_RX);
	USART2_Init();
}

/**
 * @func	PollRxBuff
 *
 * @brief	process dataframe
 *
 * @param	none
 *
 * @retval	return State of UART
 */
uint8_t PollRxBuff()
{
	uint8_t byRxData;
	uint8_t byUartState= (uint8_t)UART_STATE_IDLE;
	while((bufNumItems(&QueueRx)!=0)&&(byUartState==UART_STATE_IDLE))
	{
		bufDeDat(&QueueRx,&byRxData);
		switch (byRxBufState)
		{
		case RX_STATE_START_BYTE:
			if(byRxData==FRAME_SOF)
			{
				byIndexRxBuf=0;
				byCheckXorRxBuf=CXOR_INIT_VAL;
				byRxBufState = RX_STATE_DATA_BYTES;
			}
			else if( byRxData == FRAME_ACK)
			{
				byUartState = UART_STATE_ACK_RECEIVED;
			}
			else if ( byRxData == FRAME_NACK)
			{
				byUartState = UART_STATE_NACK_RECEIVED;
			}
			else
			{
				byUartState = UART_STATE_ERROR;
			}
			break;
		case RX_STATE_DATA_BYTES:
			if(byIndexRxBuf < RX_BUFFER_SIZE)
			{
				RxBuffer[byIndexRxBuf] = byRxData;
				if(byIndexRxBuf>0)
				{
					byCheckXorRxBuf ^= byRxData;
				}
				if (++byIndexRxBuf == *RxBuffer)
				{
					byRxBufState = RX_STATE_CXOR_BYTE;
				}
			}
			else
			{
				byRxBufState = RX_STATE_START_BYTE;
				byUartState = UART_STATE_ERROR;
			}
			break;
		case RX_STATE_CXOR_BYTE:
			if ( byRxData== byCheckXorRxBuf )
			{
				byUartState = UART_STATE_DATA_RECEIVED;
			}
			else
			{
				byUartState = UART_STATE_ERROR;
			}
		default:
			byRxBufState = RX_STATE_START_BYTE;
			break;
		}
	}
	return byUartState;
}

/**
 * @func	check_data_transmis
 *
 * @brief	check data received && run task follow data
 *
 * @param	none
 *
 * @retval	none
 */
static void check_data_transmis()
{
	if ( CMD_ID == 0x01)
	{
		if ( CMD_TYPE == 0x02)
		{
			if ( CMD_DATA_1 == 0x01)//left board
			{
				if( CMD_DATA_LED_ONOFF == CMD_DATA_2 )
				{
					LedControl_SetColorGeneral(LED_KIT_ID0,CMD_DATA_2,100);
					LED_PacketRespond(LED_KIT_ID0,CMD_DATA_2,CMD_DATA_LED_ONOFF);
				}
				else
				{
					LedControl_SetColorGeneral(LED_KIT_ID0,CMD_DATA_2,0);
					LED_PacketRespond(LED_KIT_ID0,CMD_DATA_2,CMD_DATA_LED_ONOFF);
				}
			}
			else if( CMD_DATA_1 == 0x02)//right board
			{
				if( CMD_DATA_LED_ONOFF == CMD_DATA_2 )
				{
					LedControl_SetColorGeneral(LED_KIT_ID1,CMD_DATA_2,100);
					LED_PacketRespond(LED_KIT_ID1,CMD_DATA_2,CMD_DATA_LED_ONOFF);
				}
				else
				{
					LedControl_SetColorGeneral(LED_KIT_ID1,CMD_DATA_2,0);
					LED_PacketRespond(LED_KIT_ID1,CMD_DATA_2,CMD_DATA_LED_ONOFF);
				}
			}
		}
	}
	else if ( CMD_ID == 0x04 )//buzzer
	{
		if (CMD_TYPE == 0x02 )
		{
			if(CMD_DATA_1 == 0x64)
			{
				BuzzerControl_SetMelody(pbeep);
				Buzzer_PacketRespond(0);
			}
		}
	}
	else if ( CMD_ID == 0x82 )//button
	{
		if (CMD_TYPE == 0x02 )
		{
			if(CMD_DATA_1 == 0x1)//B1
			{
				sendData_toHost(ID_TEMP,temperture);
			}
			else if( CMD_DATA_1 == 0x2)//B2
			{
				sendData_toHost(ID_HUMI,humidity);
			}
			else if( CMD_DATA_1 == 0x3)//B3
			{
				sendData_toHost(ID_LIGHT,light);
			}
			else if( CMD_DATA_1 == 0x4)//B4
			{
				LedControl_SetColorGeneral(LED_KIT_ID1,LED_COLOR_GREEN,100);
			}
			else if( CMD_DATA_1 == 0x5)//B5
			{
				LedControl_SetColorGeneral(LED_KIT_ID1,LED_COLOR_GREEN,0);
			}
		}
	}
}

/**
 * @func	sendData_toHost
 *
 * @brief	Send dataframe to Host
 *
 * @param	value of humidity
 *
 * @retval	none
 */
void sendData_toHost(uint8_t ID,uint16_t data)
{
	FRAME_ID = ID ;
	FRAME_TYPE = 0x00 ;
	FRAME_DATA1= (uint8_t) (data>>8);
	FRAME_DATA2= (uint8_t) (data>>0);
	FRAME_SEQUECE= Sequece;

	uint8_t CheckXOR= 0xff ^ frame[2] ^ frame[3] ^ frame[4] ^ frame[5] ^ frame[6] ^ frame[7];
	frame[8] = CheckXOR;

	for(uint8_t i=0;i<9;i++)
	{
		USART_SendData(USART2,frame[i]);
		while(!USART_GetFlagStatus(USART2, USART_FLAG_TXE));
	}
	Sequece++;
}

/**
 * @func	tempHum_Scan
 *
 * @brief	Get value of temperature and humidity from sensor && print to LCD
 *
 * @param	none
 *
 * @retval	none
 */
void tempHum_Scan()
{
	if(TempHumCheck==1)
	{
		TempHumCheck=0;
		TimerChangePeriod(TempHumScan,3000);
	}
	temperture =(uint8_t) (TemHumSensor_GetTemp()/100);
	humidity =(uint8_t) (TemHumSensor_GetHumi()/100);

	/*hiển thị ra LCD*/
	memset(str1,0,sizeof(str1));
	sprintf(str1,"Temp = %d oC   ",temperture);
	ucg_DrawString(&ucg,5,32,0,str1);

	memset(str2,0,sizeof(str2));
	sprintf(str2,"Humi = %d %%    ",humidity);
	ucg_DrawString(&ucg,5,52,0,str2);
}

/**
 * @func	light_Scan
 *
 * @brief	Get value of light from sensor && print to LCD
 *
 * @param	none
 *
 * @retval	none
 */
void light_Scan()
{
	light= LightSensor_MeasureUsePollingMode();
	/*hiển thị ra LCD*/
	memset(str3,0,sizeof(str3));
	sprintf(str3,"Light = %d lux    ",light);
	ucg_DrawString(&ucg,5,72,0,str3);
}

/**
 * @func	Task_multiSensorScan
 *
 * @brief	turn on sensor scan
 *
 * @param	none
 *
 * @retval	none
 */
void Task_multiSensorScan()
{
	if(TempHumScan != NO_TIMER || LightScan !=NO_TIMER)
	{
		TimerStop(TempHumScan);
		TimerStop(LightScan);
	}
	TempHumScan=TimerStart("Temp and Humi",1000,TIMER_REPEAT_FOREVER,tempHum_Scan,NULL);
	LightScan=TimerStart("Light",1000,TIMER_REPEAT_FOREVER,light_Scan,NULL);
}

/**
 * @func	processSerialReceiver1
 *
 * @brief	process data follow UART state
 *
 * @param	none
 *
 * @retval	none
 */
void processSerialReceiver1()
{
	uint8_t stateRx;
	stateRx=PollRxBuff();
	if(stateRx != UART_STATE_IDLE)
	{
		switch ( stateRx)
		{
		case UART_STATE_ACK_RECEIVED:
			printf("UART_STATE_ACK_RECEIVED\r\n");
			break;
		case UART_STATE_NACK_RECEIVED:
			printf("UART_STATE_ACK_RECEIVED:\r\n");
			break;
		case UART_STATE_DATA_RECEIVED:
			printf("UART_STATE_DATA_RECEIVED:\r\n");
			check_data_transmis();
			break;
		case UART_STATE_ERROR:
		case UART_STATE_RX_TIMEOUT:
			printf("UART_STATE_RX_TIMEOUT\r\n");
			break;
		default:
			break;
		}
	}
}

/**
 * @func	LED_PacketRespond
 *
 * @brief	Send packet respond of LED to host
 *
 * @param	[uint8_t id]: id of led ( left or right board )
 * @param	[uint8_t color]: color of led ( red, green, blue, white, black )
 * @param	[uint8_t state]: ON or OFF led
 *
 * @retval	none
 */
void LED_PacketRespond(uint8_t id, uint8_t color, uint8_t state)
{
	frameLED[5] = id ;
	frameLED[6] = color;
	frameLED[9] = state;
	frameLED[10] = Sequece;

	uint8_t CheckXOR= 0xff ^ frameLED[2] ^ frameLED[3] ^ frameLED[4] ^ frameLED[5] ^ frameLED[6] ^ frameLED[7] ^ frameLED[8] ^ frameLED[9] ^ frameLED[10];
	frameLED[11] = CheckXOR;

	for(uint8_t i=0;i<12;i++)
	{
		USART_SendData(USART2,frame[i]);
		while(!USART_GetFlagStatus(USART2, USART_FLAG_TXE));
	}
	Sequece++;
}

/**
 * @func	Buzzer_PacketRespond
 *
 * @brief	Send packet respond of Buzzer to host
 *
 * @param	[uint8_t state]: ON or OFF
 *
 * @retval	none
 */
void Buzzer_PacketRespond(uint8_t state)
{
	frameBuzzer[5] = state ;
	frameBuzzer[6] = Sequece;

	uint8_t CheckXOR= 0xff ^ frameBuzzer[2] ^ frameBuzzer[3] ^ frameBuzzer[4] ^ frameBuzzer[5] ^ frameBuzzer[6];
	frameBuzzer[7] = CheckXOR;

	for(uint8_t i=0;i<12;i++)
	{
		USART_SendData(USART2,frame[i]);
		while(!USART_GetFlagStatus(USART2, USART_FLAG_TXE));
	}
	Sequece++;
}

/**
 * @func	AppInitCommon
 *
 * @brief	Initialization Peripheral and sensor
 *
 * @param	none
 *
 * @retval	none
 */
void AppInitCommon()
{
	SystemCoreClockUpdate();
	Serial_Init1();
	TimerInit();
	BuzzerControl_Init();
	LedControl_Init();
	LightSensor_Init(ADC_READ_MODE_DMA);
	TemHumSensor_Init();
	Ucglib4WireSWSPI_begin(&ucg, UCG_FONT_MODE_SOLID);
	ucg_ClearScreen(&ucg);
	ucg_SetFont(&ucg,ucg_font_ncenR10_hr);
	ucg_SetColor(&ucg,0,255,255,255);
	ucg_SetColor(&ucg,1,0,0,0);
	ucg_SetRotate180(&ucg);
}

int main(void)
{
	AppInitCommon();
	Task_multiSensorScan();
	while(1)
	{
		processSerialReceiver1();
		processEventScheduler();
		processTimerScheduler();
	}
	return 0;
}
